# Lostorm
Lostorm is a simplistic and basic ORM to deal with PostgreSQL databases. Requiring very little boilerplate code, this ORM is lightweight and can be setup very quickly.
### Dependency Setup
###### Warning: Apparently Github Package Repository requires authentications to download packages. While I work on publishing this somewhere else a workaround is to autheneticate with Github directly at this URL, https://maven.pkg.github.com/lost-illusi0n/lostorm/net/lostillusion/lostorm/mapper. Doing this should allow Gradle to download the packages.
##### Gradle
```
plugins {
    id 'org.jetbrains.kotlin.kapt' version '1.3.72'
}
repositories {
    maven { url('https://maven.pkg.github.com/lost-illusi0n/lostorm') }
}
dependencies {
    kapt 'net.lostillusion.lostorm:annotation-processor:1.1.0'
    implementation 'net.lostillusion.lostorm:annotations:1.1.0'
    implementation 'net.lostillusion.lostorm:mapper:1.1.0'
}
```
##### Maven
```
TODO (Feel free to PR this)
```
### How does this work?
In Lostorm, you work with ``Entity``s and data classes. These entities are autogenerated by dataclasses annotatated with the ``EntityDataClass`` annotation. This greatly reduces common boilerplate you might find in other ORMs. A common dataclass may look something like
```kotlin
@EntityDataClass
data class Human(val name: String, val alive: Boolean)
```
These two lines will generate a ``Entity``. This entity will be used within DSLs and internally by Lostorm.
### Examples
#### Session Initialization
The session class is what will make the clock tick. Using this you can query and update your database with the DSL provided to you by Lostorm or even raw SQL.
```kotlin
val session = Session("jdbc:postgresql://example", "user", "pass", "org.postgresql.Driver")
```
#### Realworld Examples
These examples will show you how you might interact with Lostorm in a real project.
##### Model Setup
```kotlin
@EntityDataClass
data class Human(val name: String, val alive: Boolean)
```
##### DSL Examples
```kotlin
session {
    //Query transactions will return a list of the dataclass you first made, making it easy to work with the results.
    transaction { select(HumanEntity) }.forEach(::println)

    //You can even just do counts in the SQL itself in Lostorm.
    transaction { select(HumanEntity).count() }.let { println("Total of $it humans!") }

    //Update transactions will return an integer of rows updated.
    transaction { insert(HumanEntity).values(Human("Mark", true)) }.let { println("Inserted $it rows!")}

    //Updating entire rows or specific columns is also easy with Lostorm.
    //Heres how you would change every Ashley to be not alive.
    transaction { update(HumanEntity).set(HumanEntity.alive eq false).where(HumanEntity.name eq "Ashley") }.let { println("$it Ashley(s) are now dead!") }
    
    //Heres how you would update all rows of alive Ashleys to not alive Ashs
    transaction { update(HumanEntity).set(Human("Ash", false)).where(Human("Ashley", true)) }

    //Delete transactions will also return the amount of rows affected
    transaction { delete(HumanEntity).where(HumanEntity.alive eq false) }.let { println("$it rows deleted!") }
}
```
### Wiki (W.I.P)
#### Currently Supported Field Types
- String
- Boolean
- Int
- *More in the future, create an issue if one is missing.*
#### Column Customization
You may want to make certain columns nullable or unique, which is completaly doable with Lostorm.
```kotlin
@EntityDataClass
data class Human(
    @Columns(unique = true) val name: String, 
    @Columns(nullable = true) val middleName: String?, 
    val alive: Boolean
)
```
